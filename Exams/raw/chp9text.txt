11/17/24, 12:11 PM zyBooks 
9.1 Web storage 
Web Storage API 
The Web Storage AP/ provides storage objects that allow JavaScript programs to securely store 
key/value pairs in the web browser. The Web Storage API supports two storage objects: 
1. The sessionStorage object stores key/value pairs for an origin that are only available for the 
duration of the session. Closing the browser or browser tab ends the session. 
2. The loca/Storage object stores key/value pairs for an origin that are stored indefinitely. 
An origin is a combination of scheme, hostname, and port number in a URL. Each of the following are 
examples of different origins: 
• http://example.com/ 
• http://www.example.com/ 
• https://www.example.com/ 
• http://www.example.com:8080/ 
The browser stores the data for each origin separately and does not share the data between origins. 
I PARTICIPATION 
ACTIVITY 9.1.1: Web storage. 
1) Refreshing a webpage begins a new 
session. 
0 True 
0 False 
2) Data that should remain after the user 
closes a web browser should be stored 
in sessionStorage. 
0 True 
0 False 
3) The webpage from http://google.com/ 
cannot access web storage data from 
https://google.com/. 
0 True 
O False 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
D 
0 
0 
0 
1/37 
11/17/24, 12:11 PM zyBooks 
Chrome DevTools displays web storage 
◄ 
Most web browsers allow developers to see the key/value pairs stored in web storage. 
Chrome's DevTools displays the key/value pairs stored for the origin 
http://taz.harding.edu below and allows the developer to edit and delete key/value 
pairs. Good practice is to avoid storing sensitive data like social security numbers, 
financial data, and passwords in web storage, because the values can be easily seen by 
others. 
□ X 
/ ['.'] Web Storage AP I erno X 
C I (D taz.harding,edu/~fmc:cown/storage,html * 
S tti' e ngs. 
Pla -er Nmn e: ~IJ_en_n_y _______ ~ 
Difficulty LeYel: J ~3--~ 
I Save I 
Beme:nts Console Sources N-eti.vork Trmo:Iine Applica on » X 
Ap-plic ion 
I Manife, 
(I: Service Workers 
ii C1earstorage 
Storage. 
T 55 Local Storage 
55 h './ / ,az hanf g..edu 
► 55 Sesswn Storage 
ie!l In e dDB 
51 WebSQL 
► Co ies ,,. e X 
Con-sole l Ne ark condition5 Sensors 
Ed., -V.:ilue" 
Delet e 
X 
Private browsing 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
► 
2/37 
11/17/24, 12:11 PM zyBooks 
◄ 
Many web browsers allow users to browse the web privately using "incognito" mode or 
"private windows". When browsing privately, web storage may be disabled or may be 
cleared when the user stops browsing privately See the Exploring further section for 
information on detecting the availability of localStorage. 
Accessing web storage data 
The localStorage and sessionStorage objects provide methods for storing data, retrieving 
data, and removing data: 
• setltem(key, value) stores the key string and associated value string in storage. 
► 
• getltem(key) returns the value associated with the key in storage or null if the key does not 
exist. 
• removeltem(key) removes the key and associated value from storage. 
• clear() removes all keys and associated values from storage. 
I PARTICIPATION 
ACTIVITY 9.1.2: Storing and retrieving values from localStorage. 
<hl>Settings</hl> 
<label>Player Name: 
D 
Settings <input type="text" id="playerName" value="Player 1"> 
</label> Player Name: ! Jenny """;:::::::::::::=,-...., 
<label>Difficulty Level: Difficulty Level: !._3 _ ___. <input type="number" min="l" max="3" id="diffLevel" value="l"> 
</label> 
<input type="button" value="Save" id="saveBtn" > 
let playerNameWidget = document . getElementByid ("playerName" ); 
let difficultyLevelWidget = document . getElementByid ( "diffLevel" ); 
if (localStorage . getitem ("playerName" )) { 
( Save ) 
playerNameWidget . value = localStorage . getitem ("playerName" ); 
difficultyLevelWidget . value = localStorage . getitem ( "difficultyLevel" ); 
document . getElementByid ( "saveBtn" ) . addEventListener ( "click" , function () { 
localStorage . setitem ( "playerName" , playerNameWidget . value ); 
localStorage . setitem ( "difficultyLevel" , difficultyLevelWidget . value ); 
} ) ; 
Animation content: 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
local storage 
playerName = 
Jenny 
difficultyLevel = 
3 
3/37 
11/17/24, 12:11 PM 
The following HTML is displayed. 
<h1 >Settings</h1 > 
Player Name: 
<input type="text" id="playerName" value="Player 1 "> 
Difficulty Level: 
zyBooks 
<input type="number" min="1" max="3" id="diffLevel" value="1 "> 
<input type="button" value="Save" id="saveBtn"> 
The following JavaScript is displayed: 
let playerNameWidget = document.getElementByld("playerName"); 
let difficultyLevelWidget = document.getElementByld("diffLevel"); 
if (localStorage.getltem("playerName")) { 
playerNameWidget.value = localStorage.getltem("playerName"); 
difficultyLevelWidget.value = localStorage.getltem("difficultyLevel"); 
} 
document.getElementByld("saveBtn").addEventlistener("click", function() { 
localStorage.setltem("playerName", playerNameWidget.value); 
localStorage.setltem("difficultyLevel", difficultyLevelWidget.value); 
}); 
The browser displays two input boxes labeled Player Name and Difficulty level. Below the input 
boxes is a Save button. 
A box entitled local storage has the starting value of Empty in it. 
Step 3: The user enters Jenny and 3 in the form. 
Step 4: The name Jenny and difficult level 3 replace "Empty" in localStorage. 
Step 5: The statement if (localStorage.getltem("playerName")) is true, so playerNameWidget.value 
and difficultyLevelWidget.value are assigned Jenny and 3. 
Animation captions: 
1. The form displays the default values "Player 1" and "1" in the browser. 
2. localStorage.getltem() returns null because the playerName has not been previously saved in 
localStorage. The default HTML values remain in the browser. 
3. The user changes the player name and difficulty level and clicks Save. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 4/37 
11/17/24, 12:11 PM zyBooks 
4. The Save button's click handler calls localStorage.setltem() to save the player name and 
difficulty level to local storage. 
5. When the page is reloaded, the player name and difficulty level are loaded from localStorage 
using localStorage.getltem(). 
I PARTICIPATION 
ACTIVITY 9.1.3: Web storage methods. D 
Refer to the animation above. 
7) If local storage is empty and the Settings webpage is 0 
loaded into the browser, what does 
localStorage.getitem("difficultyLevel") 
return? 
0 117 11 
0 null 
0 false 
2) Suppose localStorage is empty, and the Settings 0 
webpage is loaded in the browser. If the user clicks 
the Save button without changing the difficulty level, 
what does 
localStorage . getitem("difficultyLevel") 
return? 
0 117 11 
0 11311 
0 null 
3) If the user sets the difficulty level to 2, 0 
clicks Save, closes the browser, reopens the browser, and navigates to 
the Settings webpage, what difficulty 
level is displayed? 
0 1 
0 2 
0 null 
4) If localStorage stores the difficulty level "3" and then 0 
local Storage. clear () is called, what does 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 5/37 
11/17/24, 12:11 PM zyBooks 
localStorage.getitem("difficultyLevel") 
return? 
0 
0 
0 
I CHALLENGE 
ACTIVITY 
117 11 
11311 
null 
9 .1.1: Web storage. 
570104.2065416.qx3zqy7 
-
Using sessionStorage, store a key of "name" with value of "Bob". 
1 
2 /* Your solution goes here*/ 
3 
1 
Check 
-
View your last submission v 
Exploring further: 
• Web Storage API from MDN 
2 
• Feature-detecting localStorag~ from MON 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
D 
3 
6/37 
11/17/24, 12:11 PM zyBooks 
9.2 Token-based user authentication (Node) 
Overview 
User authentication is the process of verifying that a user is who the user claims to be. Many websites 
authenticate users based on a user provided username and password. Some websites supplement 
passwords with security questions, security images, and other techniques. Using usernames and 
passwords to authenticate users is certainly not foolproof, but the technique is currently the most 
common form of user authentication. 
To implement user authentication, most websites use token-based authentication. Token-based 
authentication is a technique where the client uses a signed token to "prove" to a server that the client 
has successfully authenticated. A signed token is a string of characters produced with a secret key 
that uniquely identifies the entity that created the token. 
I PARTICIPATION 
ACTIVITY 9.2.1 : Token-based authentication process. D 
Web browser Web server 
l
s1Cr I http://google.com/ POST bsmith/password .. .,, User is valid 
1 .... token 
ml ~ 
GET api/calendar .. 
.,, Q token is valid 
I ~ 
calendar data 
Animation content: 
A web browser is shown with a username and password field. When the user types in the username 
bsmith and password, a POST request with bsmith/password is sent to the web server for 
authentication. Once validated, the web server sends back a token. The web app request bsmith's 
calendar with GET api/calendar and the token is sent back the the web server for validation. Once 
the token is found valid, bsmith's calendar information is sent back to the web browser and 
displayed on the screen. 
Animation captions: 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 7/37 
11/17/24, 12:11 PM zyBooks 
1. User authenticates by entering a username and password, which are sent to the web server. 
2. Web server verifies the username and password are valid and generates a token. 
3. The token is returned to the web browser and stored for future requests. 
4. Web app requests bsmith's calendar, so the token is sent in the web API request. 
5. Web server validates bsmith's token and returns back bsmith's calendar data. 
I PARTICIPATION 
ACTIVITY 9.2.2: Steps in token-based authentication. 
Match each request or response with the action the request or response generates. 
If unable to drag and drop, refresh the page. 
Client sends username and password for authentication. 
Server responds with data when given a valid token. Server generates a token. 
Client sends the token with an API request. 
JSON Web Tokens (JWT) 
Server verifies the username and 
password. 
Client stores the token for future 
requests. 
Server validates the token. 
Client receives API response. 
D 
JSON Web Tokens are a popular way of implementing tokens in token-based authentication. A JSON 
Web Token (JWT), pronounced "jot", is a string produced by the server that encodes JSON data. The 
string is signed with a secret key known only by the server to ensure the data in a JWT is unaltered by 
the client. JWTs are composed of three parts separated by periods: Header. Payload. Signature. 
JSON data is base64 encoded in a JWT. Base64 encoding is a technique that converts data into 64 
printable characters. 
I 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 8/37 
11/17/24, 12:11 PM I PARTICIPATION I 
ACTIVITY 9.2.3: Creating a JWT. 
Header: { " typ" : "JWT" , "alg" : "HS256" } 
Payload: { "username" : "bob" } 
Secret Key: supersecret 
I Encode) 
B 
zyBooks 
8 Header: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 . 
JWT Payload: eyJlc2VybmFtZSI6ImJvYiJ9 . 
Signature: Mrn0fNOZMBFOrFu99NlnHdz3jkp5IE_BQCNOz4shlepQ 
Animation content: 
A header, payload, and secret key contain the following before being encoded: 
Header: {"typ":"JWT","alg":"HS256"} 
Payload: {"username":"bob"} 
Secret Key: supersecret 
The header and payload are encoded with Base64 and stored in the token as the following: 
Header: eyJ0eXAiOiJKVl QiLCJhbGciOiJIUzll NiJ9. 
Payload: eyJl c2VybmFtZSl6ImJvYiJ9 
A signature is stored in the token and reads: 
Signature: Mm0fNOZMBFOrFu99NlnHdz3jkp5IE_BQCNOz4sh1 epQ 
Animation captions: 
u 
1. The Header contains the type of token (JWT) and the algorithm used to sign the token (HMAC 
SHA256). 
2. The Header is Base64 encoded. 
3. The Payload containing the information to transmit is Base64 encoded. 
4. The Signature is created using the HMAC SHA256 algorithm on the base64-encoded Header+ 
base64-encoded Payload + Secret Key. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 9/37 
11/17/24, 12:11 PM zyBooks 
When the client sends a JWT back to the server, the server validates the JWT by generating a new 
signature based on the JWT's base64 encoded header and payload and the server's secret key. If the 
payload was not modified, the new signature should be identical to the JWT's signature. 
I PARTICIPATION 9.2.4: JSON Web Tokens. ACTIVITY 
1) JWTs almost always have the same 
header. 
0 True 
O False 
2) JWTs almost always have the same 
payload. 
0 True 
0 False 
3) A JWT's payload can only include the 
user's username. 
0 True 
O False 
4) If the client changes one character of 
the JWT, the JWT will fail validation on 
the server. 
0 True 
O False 
5) If a client knows the server's secret key, 
the client can create JWTs with any 
payload that the server will accept as 
valid JWTs. 
O True 
O False 
jwt-simple module 
D 
0 
0 
0 
0 
0 
The jwt-simple module is used to encode and decode JWTs in Node.js web applications. The jwtsimple module is installed using: npm install j wt-simple. jwt-simple provides an jwt.encode() 
method to create a JWT and ajwt.decode() method to decode a JWT. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 10/37 
11/17/24, 12:11 PM zyBooks 
Figure 9.2.1: Encoding and decoding a JWT with the jwt-simple module. 
canst jwt = require ("jwt-simple" ); 
canst secret = "supersecret" ; 
canst payload = { username : "bsmith" }; 
II Create a JWT 
canst token = jwt . encode (payload, secret); 
console . log ("Token: " + token ); 
II Decode a JWT 
canst decoded = jwt . decode (token , secret); 
console . log ("Decoded payload: " + decoded . username ); 
Token: 
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJlc2VybmFtZSI6ImJvYiJ9.Mm0fNOZMBFOrFu99NlnHdz3jkp5IE_BQ 
Decoded payload: bsmith 
◄ --------------------------------
The figure below uses jwt-simple in the context of an Express server with two routes: 
1. / api/ auth-Accepts a username and password in a POST request. After verifying the 
username is "bsmith" and password is "pass", the route sends back a JWT carrying a payload 
containing bsmith's username. 
2. I api/ status -Accepts a GET request and expects the X-Auth header to contain the JWT 
obtained from the/ api/ auth route. After validating the JWT, the route sends back bsmith's 
status. 
Developers can use a tool like Postman to test the Express server with the example HTTP requests 
shown at the bottom of the figure below. 
Figure 9.2.2: Using jwt-simple in an Express server. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
► 
11/37 
11/17/24, 12:11 PM zyBooks 
canst express = require ( "express" ); 
canst bodyParser = require ("body-parser" ); 
canst jwt require ( "jwt-simple" ); 
canst app = express (); 
canst router = express . Router (); 
II Parse application/x-www-form-urlencoded 
router . use (bodyParser . urlencoded ( 
{ extended : false })); 
II Secret used to encode/decode JWTs 
canst secret = "supersecret" ; 
router . post ("/auth" , function (req, res) 
} ) ; 
II Verify bsmith/pass was POSTed 
if (req . body . username === "bsmith" && reg . body . password === "pass" ) 
II Send back a token that contains the user's username 
canst token = jwt . encode ({ username : "bsmith" }, secret); 
res . json ({ token : token }); 
else { 
II Unauthorized access 
res . status (401) . json ({ error: "Bad username/password" }); 
router . get ("/status" , function (req, res) 
} ) ; 
II Check if the X-Auth header is set 
if (! req . headers [ "x-auth" ]) 
return res . status (401) . json ({ error: "Missing X-Auth header" }); 
II X-Auth should contain the token value 
canst token = req . headers [ "x-auth" ]; 
try { 
canst decoded = jwt . decode (token , secret); 
II Send back a status 
if (decoded . username === "bsmith" ) 
res . json ({ status: "Enjoying a beautiful day!" }); 
else { 
res . json ({ status: "Working hard!" }); 
catch (ex ) 
res . status (401) . json ({ error: "Invalid JWT" }) ; 
app . use ("/api" , router); 
app . listen (3000); 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 12/37 
11/17/24, 12:11 PM zyBooks 
HTTP request HTTP response 
POST /api/auth HTTP/1.1 HTTP/1.1 200 OK 
Host : localhost:3000 
User-Agent: Mozilla/5.0 
Chrome/48.0.2564 
Content-Type: application/xwww-form-urlencoded 
Content-Type: application/json; charset=utf-8 
Content-Length: 121 
Date: Tue, 03 May 2016 15:22:17 GMT 
ETag: W/"79-d6Dq2n+D6aIQoSfkTMks8w" 
X-Powered-By: Express 
username=bsmith&password=pass {"token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9. E 
yuHqmPCsMMWPZvVflRwxkJV3o1Gk0xsUfaCI7wmleC0"} 
GET /api/status HTTP/1.1 
Host: localhost:3000 
HTTP request 
User-Agent: Mozilla/5.0 Chrome/48.0.2564 
Content-Type: application/x-www-form-urlencoded 
X-Auth: 
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJlc2VybmFtZSI6ImJzbW10aCJ9. 
yuHqmPCsMMWPZvVflRwxkJV3o1Gk0xsUfaCI7wmleC0 
I PARTICIPATION 
ACTIVITY 9.2.5: JWTs in an Express server. 
Refer to the code in the figure above. 
1) What status code is returned when a 
POST to/ api/ auth contains the 
username "bmsith" and the password 
"opensesame"? 
0 200 
0 401 
0 404 
2) What status code is returned when a 
GET to /api/status does not 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
HT 
HTTP/1.1 21 
Content-Ty] 
applicatio1 
charset=ut: 
Content-Lei 
Date: Tue, 
15: 24: 33 GI 
ETag: 
W/"26-/MFB• 
X-Powered-1 
{"status":' 
beautiful < 
D 
0 
0 
13/37 
11/17/24, 12:11 PM 
contain an X-Auth header? 
0 200 
0 401 
0 404 
3) Can the Express server above return a 
token that would later cause the 
"Working hard!" status to be returned by 
/api/status? 
0 Yes 
Q No 
Storing the secret key. 
zyBooks 
The examples in this section show the secret key used to sign the JWT in the source 
code. Good practice is to store the secret key in a configuration file and use a long 
randomized string for the secret key Ex: qs3h6z0JUN9wgTy1j2Cl54g86yzG is a good 
secret key 
◄ 
Using a database 
0 
► 
Authentication services generally store and retrieve data from a database. The figure below shows a 
Node.js project that stores data in a MongoDB database using a Mongoose model called User. The 
user model stores a username, password, and status for a user. The Express server has three routes: 
1. / api/user -Accepts a username, password, and status in a POST request. The route adds a 
new user to the database. 
2. I api/ auth-Accepts a username and password in a POST request. The route verifies the 
POSTed username/password matches a username/password from the database and returns a 
JWT with the username in the payload. 
3. I api/ status -Accepts a GET request and expects the X-Auth header to contain a valid JWT. 
The route validates the JWT and sends back the username and status of all users in the 
database. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 14/37 
11/17/24, 12:11 PM zyBooks 
Figure 9.2.3: Node.js project uses token-based authentication with user data 
in a MongoDB database. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 15/37 
11/17/24, 12:11 PM zyBooks 
myproject 
----
t= 
api 
L_ users. j s 
models 
L_ user.js 
node modules 
~ express 
~ mongoose 
~ jwt-simple 
L_ etc . .. 
db.js 
package.json 
server.js 
II modelsluser.js 
const db = require ( " .. /db" ); 
II Create a model from the schema 
const User = db . model ( "User" , { 
username : { type : String, required : true 
} , password : type : String, required : true 
} , status: String 
} ) ; 
module . exports User; 
II db.js 
const mongoose = require ("mongoose" ); 
mongoose . connect ("mongodb://localhost/mydb" ); 
module . exports = mongoose ; 
II server.js 
const express = require ("express" ); 
const bodyParser = require ("body-parser" ); 
const User = require ("./models/user" ); 
const app = express (); 
const router = express .Router (); 
router . use (bodyParser . urlencoded ( 
{ extended : false })); 
router . use ("/api" , require ("./api/users" )); 
app . use (router); 
app . listen (3000); 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
I 
16/37 
11/17/24, 12:11 PM 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
zyBooks 
II api/users.js 
canst jwt = reguire ("jwtsimple" ); 
canst User = 
reguire ( " .. /models/user" ); 
canst router = 
reguire ("express" ) . Router (); 
II For encoding/decoding JWT 
canst secre t = 
"supersecret" ; 
II Add a new user to the 
database 
router . post ( "/user" , 
function (reg, res) { 
if (! reg . body . username I I 
!reg . body . password) { 
res . status (400) . json ({ 
error : "Missing username 
and/or password" }); 
return ; 
canst newUser new 
User ( { 
username : 
reg . body . username , 
password : 
reg . body . password, 
status: 
reg . body . status 
} ) ; 
newUser . save (function (err) 
if (err) { 
res .status (400) . send (err); 
} 
else { 
res . sendStatus (201); // 
Created 
} ) ; 
} ) ; 
} 
II Sends a token when given 
valid username/password 
router . post ("/auth" , 
function (reg, res) { 
if (! reg . body . username I I 
! reg . body . password) { 
res . status (401) . json ({ 
error: "Missing username 
and/or password" }); 
17/37 
11/17/24, 12:11 PM 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
zyBooks 
return ; 
II Get user from the 
database 
User . findOne ({ username : 
req . body . username }, 
function (err, user) { 
if (err) { 
res . status (400) . send (err); 
} 
else if (! user) 
II Username not in 
the database 
res . status (401) . json ({ 
error : "Bad username" }); 
else { 
II Check if 
password from database 
matches given password 
if (user . password 
!= req . body . password) { 
res . status (401) . json ({ 
error : "Bad password" }); 
} 
else { 
II Send back a 
token that contains the 
user's username 
const token 
jwt . encode ({ username : 
user . username }, secret); 
res . j son ( { 
token : token }) ; 
} 
} 
} ) ; 
} ) ; 
II Gets the status of all 
users when given a valid 
token 
router . get ("/status" , 
function ( req , res) { 
II See if the X-Auth 
header is set 
if (! req . headers [ "xauth" ]) { 
return 
res .status (401) . json ({ error : 
"Missing X-Auth header" }); 
} 
II X-Auth should contain 4- i.,._ 4- ...... 1.,. ,__ ..... 
18/37 
11/17/24, 12:11 PM 
I 
zyBooks 
I 1.-llt:: l-Vl'Ct::11 
canst token 
req . headers [ "x-auth" ); 
try { 
canst decoded I PARTICIPATION 
ACTIVITY 9.2.6: Token-based authentication with a MongoDB database. 
efer to the code in the figure above. 
) What does the HTTP request below do? 
POST /api/user HTTP/1.1 
Host: localhost : 3000 
Content-Type: application/x-www-form-urlencoded 
username and status fields 
Us e r . find ({}, 
"username status " , 
function (e r r , use r s ) 
res . json (users); 
} ) ; 
:ch (ex ) 
res . status (401) . json ({ 
"Invalid JWT" }); 
username=jwhite&password=qwerty&status=Working+hard! 
O Authenticates user jwhite 
0 Gets all user statuses 
0 Creates a new user 
2) If user "jwhite" with password "qwerty" is in 
the database, what response does the 
Express server return to the request below? 
POST /api/auth HTTP/1.1 
Host: localhost:3000 
Content-Type: application/x-wwwform-urlencoded 
username=jwhite&password=opensesame 
0 200 status code with a JWT 
401 status code with an error 0 message 
0 201 status code 
3) What response does the Express 
server return to the request below? 
GET / api / status HTTP / 1.1 
Host: localhost:3000 
X-Auth: jwhi te 
O 200 status code with all user 
statuses 
401 status code with an error 0 message 
0 201 status code 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
} ) ; 
module . exports router; 
I 
~ D 
0 
0 
19/37 
11/17/24, 12:11 PM zyBooks 
Saving passwords in the database 
◄ 
The examples above show passwords stored as plain text in a database. Passwords 
should NEVER be stored as plain text in a database. Instead, password hashes 
(discussed elsewhere) should be stored in the database. 
Storing JWT in localStorage 
► 
The web application running in the web browser must interact with the server's API to authenticate the 
user, save the JWT, and transmit the JWT in subsequent API requests. The window. local Storage 
object allows web applications to store data in the web browser and is ideal for storing a JWT. The 
example below uses the Fetch API to obtain and transmit a JWT. 
I PARTICIPATION 
ACTIVITY 9.2.7: Authenticating with Fetch and storing the JWT in localStorage. D 
async function login (username , password) { 
const response = await fetch ("/api/auth" , 
method : "POST" , 
} ) ; 
body : new URLSearchParams ({ 
username : username , 
password : password }) 
if (response . ok ) 
const tokenResponse = await response . json (); 
localStorage .setitem ("token" , 
tokenResponse . token ); 
async function displayStatus () { 
const token = localStorage . getitem ( "token" ); 
const response = await fetch ("/api/status" , 
headers : { "X-Auth" : token } 
} ) ; 
if (response . ok ) 
const users = await response . json (); 
let html = "" ; 
for (let user of users) { 
html += "<li>" + user . username + fl - fl + 
user .status + "</li>" ; 
const status = document . querySelector (flul" ); 
status . innerHTML = html ; 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
web browser 
local 
Storage 
http:l/localhost:3000/app 
Status: token:3a.s8.: 
I 
• bsmith - Enjoying a 
beautiful day! 
• jwhite - Working hard! 
• ablack - Doing homework 
I 
GET /api/status 
X-Auth: 3a.s8.2p 
{ usernames & 
statuses} 
Token 
validated! Express server 
Get statuses ! t { json } 
{ "username":"bsmith", 
"password":"pass", 
... }, 
{ "username":"jwhite", 
"password":"qwerty", 
... }, 
{ "username: "ablack", 
"password":"abc123", 
... } 
20/37 
11/17/24, 12:11 PM 
} 
Animation content: 
A block of JavaScript is shown: 
async function login(username, password) { 
canst response = await fetch("/api/auth", { 
method: "POST", 
body: new URLSearchParams({ 
username: username, 
password: password}) 
}); 
if (response.ok) { 
} 
} 
canst tokenResponse = await response.jsonO; 
localStorage.setltem("token", 
token Response.token); 
async function displayStatus() { 
canst token = localStorage.getltem("token"); 
canst response = await fetch("/api/status", { 
headers: { "X-Auth": token } 
}); 
if (response.ok) { 
} 
} 
canst users = await response.json(); 
let html = ""; 
for (let user of users) { 
html += "<Ii>" + user.username + " - " + 
user.status + "</Ii>"; 
} 
canst status = document.querySelector("ul"); 
status.innerHTML = html; 
zyBooks 
MongoDB 
A web browser is shown with a username and password field. The user types in the bsmith 
username and password. The following POST request is sent the the Express server: 
POST /api/auth 
username=bsmith 
password= pass 
The web server verifies the login information with a MongoDB database. The Express server sends a 
JWT token back to the web browser with the following information: 
{ "token": 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 21/37 
11/17/24, 12:11 PM zyBooks 
"3a.s8.2p"} 
The web browser stores the token in local storage. To request status the web browser sends the 
following GET request to the web server: 
GET /api/status 
X-Auth: 3a.s8.2p 
The web server validates the token and retrieves the data to be displayed on the web browser, which 
is the following information: 
Status: 
• bsmith - Enjoying a beautiful day! 
• jwhite - Working hard! 
• ablack - Doing homework 
Animation captions: 
1. The user enters a username and password and clicks Login button. 
2. To authenticate the user, the browser calls login() with the username and password. The 
fetch() method sends a POST request with username and password to /api/auth. 
3. The server verifies bsmith/pass and returns a JWT to the web browser. 
4. response.json() extracts the token from the JSON response. The setltem() method saves the 
token to localStorage. 
5. To display user statuses, displayStatus() retrieves the token from localStorage with getltem(). 
Then fetch() sends a GET request to /a pi/status with the token in the X-Auth header. 
6. Token is validated by the server, so server sends JSON with all user statuses to the browser. 
7. response.json() parses the user data. The usernames and statuses display in an unordered 
list. 
I PARTICIPATION 
ACTIVITY 9.2.8: Storing JWT in localStorage. 
Refer to the code in the animation above. 
1) local Storage does not store a JWT until 
after the user authenticates. 
O True 
O False 
2) The JWT is not stored in localStorage if 
the user provides the wrong username 
or password when authenticating. 
O True 
O False 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
D 
0 
0 
22/37 
11/17/24, 12:11 PM 
3) If the user provides the wrong 
username or password when 
authenticating, displayStatus () 
can still display the user statuses. 
0 True 
0 False 
4) If the code below executes, 
displayStatus () can no longer 
obtain the user statuses. 
localStorage . removeitem ("token" ); 
0 True 
O False 
zyBooks 
I PARTICIPATION 9.2.9: User authentication with Fetch. ACTIVITY 
Press the Display Status button before typing a username/password to see an "X-Auth 
header missing" error message. The Display Status button calls the JavaScript function 
displayStatus () . If the user is not logged in, displayStatus () sends a GET request 
to https://wp.zybooks.com/status.php?op=auth with an empty token, which returns back an 
error message. 
Enter the username "bsmith" and password "pass" and press the Login button. Then press 
the Display Status button again. The status of three users will display. Only bsmith/pass is an 
acceptable username/password. 
If the user enters a bad username or password, the webpage does not indicate so. Add the 
necessary code in login () to display an appropriate error message when the server 
returns a 401 response. 
Note that JavaScript does not use localStorage due to browser restrictions. Also, the 
URLs in the Fetch calls differ from previous examples. 
CSS I JavaScript I 
0 
0 
D 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiFall2024/chapter/9/print 23/37 
11/17/24, 12:11 PM zyBooks 
1 id="login" autocomplete="off" > 
2 <p> 
3 <label for="username" >Username: </label> 
4 <input type="text" id="username" > 
5 </p> 
6 <p> 
7 <label for="password" >Password: </label> 
8 <input type="text" id="password" > 
9 </p> 
10 <button id="loginBtn" type="button" >Login</ button > 
11 < id="errorMsg" ></p> 
12 < for > 
13 
14 <button id="statusBtn" >Display Status</button> 
15 
16 <ul> 
17 </ul> 1 
Render webpage 
Your webpage 
Usemame: 
Password: 
I Login I 
I Display Status I 
► View solution 
Reset code 
Third-party authentication 
Many web applications and mobile apps allow users to login to the web/mobile app 
using the user's account on Google, Facebook, Microsoft, etc., using an authentication 
protocol called Open/D. Open ID allows a user to login to the application without creating 
another username/password. The application does not have to manage the user's 
password or provide methods for the user to reset their password. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
.... 
24/37 
11/17/24, 12:11 PM zyBooks 
OAuth is an authorization protocol that allows a web/mobile app to access services 
from a service provider like Google, Facebook, Microsoft, etc., on behalf of the 
authenticated user. Ex: Words with Friends is a popular mobile game that uses a user's 
Facebook friends to help the user find friends to play with. 
Exploring further: 
• Authentication (TechTarget) 
◄ 
• node-jwt-simP-le 
• 0P-enID and OAuth 
9.3 Password hashing (Node) 
Cryptographic hash functions 
► 
Websites must exercise care when storing personal information about users. Numerous high-profile 
data breaches confirm that protecting personal data is very difficult to do. To protect users, 
organizations should store as little sensitive information as possible. 
Many individuals are interested in discovering the passwords used by a website's users. Therefore, 
user passwords should never be stored as plain text in a database. Instead, developers should use a 
cryptographic hash function to convert passwords into hashes and store only the hashes in the 
database. A cryptographic hash function is a mathematical algorithm that converts text of any length 
into a fixed-length sequence of characters called the hash digest or "hash". Various cryptographic 
hash functions exist including MD5, SHA-1, bcrypt, and PBKDF2. 
Figure 9.3.1: Hashing various passwords using the MD5 cryptographic hash 
function. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 25/37 
11/17/24, 12:11 PM 
◄ 
Input 
Hash 
Function 
zyBooks 
Hash Digest 
password ~ 5f 4d·cc3b5a,a765d61d8327deb882cf99 
pas:.123 ~ 32250170a0dca92d53@c9624f336ca24 
pass123 ! ~ c9d9b8cab32214716ee1b44b3aae2502 
Pa ss123 ! ~ 10487c8581423e8b2fbeed2b21c2c c53 
Try 9.3.1: Try generating your own MD5 hashes. 
1. Go to an online MD5 Hash Generator. 
► 
2. Type "password" into the text box and verify the MD5 hash is the same as the 
"password" hash digest in the figure above. 
◄ 
3. Try changing the password by a single character, and notice that the hash completely 
changes. 
I PARTICIPATION 
ACTIVITY 9.3.1: Cryptographic hash functions. 
1) The length of the hash digest is the 
same regardless of how many 
characters are in the password. 
0 True 
0 False 
2) All cryptographic hash functions 
produce the same size hash digest. 
Q True 
O False 
3) Given a hash digest, a clever hacker 
might be able to determine the original 
input that created the hash digest. 
Q True 
O False 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
► 
D 
0 
0 
0 
26/37 
11/17/24, 12:11 PM 
4) Two different inputs may exist that will 
convert into the same hash digest. 
0 True 
O False 
Hashed passwords and password cracking 
zyBooks 
0 
An authentication system should only store password hashes, not plain text passwords. To 
authenticate a user, the authentication system hashes the password submitted by the user and 
compares the hash with the hash stored in the database. If the two hashes are identical, then the user 
provided the correct password. 
I PARTICIPATION 
ACTIVITY 9.3.2: Verifying passwords by comparing password hashes. 
New user: pgreen 
opensesame 
Login attempt: 
Login attempt: 
Animation content: 
cryptographic 
hash function 
pgreen 
Open Sesame @ 
pgreen 
opensesame © 
Database 
username 
bsmith 
jwhite 
ablack 
pgreen 
passhash 
F993GH93F1 
83B8F2EE48 
49A8EF48D3 
BC029G8A38 
75EE39FA90 != BC029G8A38 
BC029G8A38 = BC029G8A38 
A database is shown with column names username and passhash. The following data is in the 
format username, passhash: 
bsmith, F993GH93F1 
jwhite, 83B8F2EE48 
ablack, 49A8EF48D3 
D 
A new user is added with the username pgreen and password opensesame. The password is sent 
through a cryptic hash function and is stored in the table as the following: 
pgreen, BC029G8A38 
When the user tries to login the tried password is sent through the cryptic hash function and 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 27/37 
11/17/24, 12:11 PM zyBooks 
checked against the passhash stored in the table. If pgreen types in OpenSesame, the hash value is 
75EE39FA90 which does not equal BC029G8A38, the passhash that is stored in the table, so pgreen 
is denied access. 
Animation captions: 
1. New user's username and password hash is added to the database. 
2. User pgreen attempts to login with the wrong password. Hash of "OpenSesame" does not 
match hash of "opensesame". 
3. User pgreen attempts to login with the correct password. Hash of "opensesame" matches 
hash of "opensesame". 
If a data breach occurs and an attacker obtains an organization's database of password hashes, the 
attacker would be unable to directly convert the hashes back into the users' original passwords. 
However, a determined attacker may use a variety of methods to crack the password hashes. 
Password cracking is the process of recovering passwords from data, like the database of a 
compromised website. 
A dictionary attack is a popular password-cracking strategy where the attacker feeds a number of 
possible passwords, such as words from a dictionary, into a hash function and compares the stolen 
hashes to the generated hashes. Passwords are revealed for any matching hashes. Dictionary attacks 
are computationally expensive, so attackers often create precomputed dictionary tables in advance. 
Developers use salt to circumvent attacks with precomputed tables. A salt is a random string that is 
combined with a password so two identical passwords produce different hashes. Cracking salted 
passwords is significantly more challenging because an attacker has to create a table for each salt 
value, which is computationally expensive. 
Figure 9.3.2: Using salt to protect against precomputed table attacks. 
◄ 
Salt + Password 
Hash 
Function Hash Digest 
p4@9s + pass113 - ~ d3ebe55d16b484e616e2c3787aed5c5a 
90sk# + pass123 - ~ c77390d36b93bf0a52a650576680c61f 
*s41<2p + pa ss 123 - ~ 9458c6e01f03645daef18cla01dec2fb 
► 
Salt does not necessarily keep attackers from cracking passwords, but strong passwords are less 
susceptible to dictionary attacks. A strong password is a password that is difficult to guess. A strong 
password has the following characteristics: 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 28/37 
11/17/24, 12:11 PM zyBooks 
• Does not contain words found in a dictionary or on the web 
• Composed of uppercase and lowercase letters, digits, and perhaps punctuation 
• At least 10 characters in length 
• Has not been used as a password before on the same website or on any other website 
• Does not conform to popular password patterns like an initial capital letter, 2-4 digits at the end, 
or adding ! at the end 
Figure 9.3.3: Secure password check indicates 'qwerty123!' is a poor 
password. 
How secure is your password? 
Tip: Try to make your passwords at least 15 characters long Show password: LI 
qwerty123! 
10 characters containing: ✓ Lowercase Upper case ✓ Numbers ✓ Symbols 
Time to crack your password: 
0.01 seconds 
Review: Oh dear, using that password is like leaving your front 
door wide open. Your password is very weak because it contains 
a common password, a sequence of characters and a dictionary 
word. 
Your passwords are never stored. Even if they were, we have no idea who you are! 
Source: !!lY.1 login.com 
◄ 
I PARTICIPATION 
ACTIVITY 9.3.3: Password hashes. 
1) If an authentication system hashes a 
user's submitted password and finds 
the hash is the same as the user's 
password hash in the database, then 
the user supplied the __ password. 
O correct 
0 wrong 
O hashed 
2) Someone who steals a database of 
password hashes may attempt a __ 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiFall2024/chapter/9/print 
► 
D 
0 
0 
29/37 
11/17/24, 12:11 PM 
attack to discover some of the 
passwords. 
0 hash 
0 dictionary 
0 salt 
3) Is the salt stored with the passwords in 
the database? 
0 Yes 
Q No 
4) Which password is a strong password? 
0 PurpleRain 
0 qwertyuiop 
0 flBPs03!5a 
5) Can a website that stores password 
hashes in their database recover lost 
passwords for their users? 
0 Yes 
Q No 
2012 Linkedln data breach 
zyBooks 
Russian cybercriminals stole 6.5 million password hashes from Linkedln on June 5, 
2012. The criminals cracked more than 60% of the unique passwords from the hashes 
and published the passwords in plain text on the web. Linkedln had used the SHA 1 hash 
function to generate the hashes but did not use salt. The data breach highlights the risk 
to users who do not use strong passwords. 
Source: 2012 Linkedln hack (.Wikig_edia). 
◄ 
bcryptjs 
0 
0 
0 
► 
Cryptography researchers have found weaknesses in older hash functions like MD5 and SHA-7 that 
make those hash functions vulnerable to attacks. Good practice is to use a strong hash function like 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 30/37 
11/17/24, 12:11 PM zyBooks 
bcrypt, scrypt, or PBKDF2, which purposely execute slowly and make password cracking significantly 
more difficult. 
The bcryptjs module is a popular module for implementing authentication in Node.js applications. 
bcryptjs is installed using: npm install bcryptj s . The module has two commonly used methods: 
1. The bcrypt.hashSync() method returns a hash value that is 60 characters long for a given 
password and "cost factor". The hash value is created by prepending a random salt to the hash 
digest. 
2. The bcrypt.compareSync() method takes a password and bcrypt hash value as arguments and 
returns true if the password is identical to the password used to create the hash value, false 
otherwise. 
An example bcrypt hash of $2a$10$33M.4Zn7R7k3jHOISHxCe.yUql4vl9mv4/oeiluhHDQZcfySVg6wC 
is composed of four parts: 
1. "2a" indicates the bcrypt algorithm created the hash. 
2. "1 O" indicates the cost factor is 10. 
3. "33M.4Zn7R7k3jHOISHxCe." is the 16-byte salt value encoded to 22 characters. 
4. "yUql4vl9mv4/oeiluhHDQZcfySVg6wC" is the 24-byte hash digest encoded to 31 characters. 
Figure 9.3.4: Generating a hash and comparing hashes with the bcryptjs 
module. 
const bcrypt = require ( "bcryptjs" ); 
II Generate 3 hashes for the same password 
for (let c = 0 ; c < 3 ; c ++) { 
let hash = bcrypt . hashSync ("opensesame" , 10 ); 
console . log ("Hash: " + hash ); 
II Compare hash produced by identical passwords 
const passwordHash = bcrypt . hashSync ( "opensesame" , 
10 ); 
if (bcrypt . compareSync ( "opensesame" , passwordHash )) 
console . log ("Same!" ); 
else { 
console . log ("Not the same" ); 
Hash: 
$2a$10$33M.4Zn7R7k3jHOISHxCe.yUqI4vl9mv4 / oeiLuhHDQZcfySVg6wC 
Hash: 
$2a$10$ByrTcHizkol25klWOnlV2egFI3DdRzo9 . xrjal/ IyiaKd8X5diFpi 
Hash: 
$2a$10$cd . MX 7Ubbm3n9Lfc8ilrgeYw3MRpJ512fUtPq4kHEQyhI8wpJ8LPq 
Same! 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 31/37 
11/17/24, 12:11 PM 
I PARTICIPATION 
ACTIVITY 9.3.4: Password hashing with bcryptjs. 
1) 
2) 
3) 
Does bcrypt. hashSync () always 
generate a unique hash for the same 
password and cost factor? 
0 Yes 
0 No 
The larger the cost factor passed to 
bcrypt. hashSync (),the __ time 
bcrypt.hashSync() takesto 
produce a hash value. 
0 less 
0 more 
What does the code below output to 
the consolel 
canst hash 
bcrypt . hashSync ( "qwerty" , 10 ); 
if 
(bcrypt . compareSync ( "Qwerty" , 
hash )) { 
console . log ( "Same!" ); 
else { 
console . log ("Not the same" ); 
0 Same! 
0 Not the same 
Using a database 
zyBooks 
D 
D 
D 
D ► 
The Node.js project in the figure below creates a web API that stores usernames, password hashes, 
and statuses in a MongoDB database. 
• The/ api/user route accepts a username, password, and status in a POST request. The 
bcrypt. hashSync () method generates a password hash, which is saved with the username 
and status to the database. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 32/37 
11/17/24, 12:11 PM zyBooks 
• The/ api/ auth route accepts a username and password in a POST request. The 
bcrypt. compare Sync () method compares the password hash from the provided password 
with the password hash in the database. If the password is correct, the route returns a JWT. 
• The/ api/ status route accepts a GET request and expects the X-Auth header to contain a 
valid JWT. The route returns a JSON-encoded list of usernames and statuses for all users in the 
database. 
Figure 9.3.5: Node.js project uses token-based authentication and password 
hashing with bcryptjs. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 33/37 
11/17/24, 12:11 PM 
myproject 
api 
L_ users. j s 
models 
L_ user.js 
node modules 
~ bcryptjs 
~ express 
~ mongoose L jwt-simple 
etc . .. 
db.js 
~ package . json 
L_ server. j s 
II modelsluser.js 
const db = require ( " .. /db" ); 
II Create a model from the schema 
const User = db . model ( "User" , { 
username : type : String, required : 
true }, 
passwordHash : 
true }, 
status : 
} ) ; 
module . exports 
II db.js 
type : String, required : 
String 
User; 
zyBooks 
const mongoose = require ("mongoose" ); 
mongoose . connect ("mongodb://localhost/mydb" ); 
module . exports = mongoose ; 
II server.js 
const express = require ("express" ); 
const bodyParser = require ("body-parser" ); 
const User = require ("./models/user" ); 
const app = express (); 
const router = express .Router (); 
router . use (bodyParser . urlencoded ( 
{ extended : false })); 
router . use ("/api" , require ("./api/users" )); 
app . use (router); 
app . listen (3000); 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 34/37 
11/17/24, 12:11 PM 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
zyBooks 
II api/users.js 
canst jwt = require ("jwt-simple 
canst User = 
require ( " .. /models/user" ); 
canst router = 
require ("express" ) . Router (); 
canst bcrypt = require ("bcryptj: 
II For encoding/decoding JWT 
canst secret = "supersecret" ; 
II Add a new user to the databa . 
router . post ("/user" , function (ri 
res) 
if (! req . body . username I I 
! req . body . password) { 
res . status (400) . json ({ er: 
"Missing username and/1 
password" }); 
return ; 
// Create a hash for the sub1 
password 
canst hash = 
bcrypt . hashSync (req . body . passwo: 
10 ); 
canst newUser = new User ({ 
username : req . body . usi 
passwordHash : hash, 
status: req . body . st, 
} ) ; 
newUser . save (function (err) 
if (err) { 
res . status (400) . send (e: 
else { 
res . sendStatus (201); 
Created 
} 
} ) ; 
} ) ; 
I I Sends a token when given val. 
username/password 
router . post ("/auth" , function (ri 
res) { 
if (! req . body . username I I 
! req . body . password) { 
res . status (401) . json ({ er: 
"Missing username and/1 
password" }); 
return ; 
35/37 
11/17/24, 12:11 PM 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
zyBooks 
II Get user from the databas, 
User . findOne ({ usernarne : 
req . body . usernarne }, function (e: 
user) { 
if (err) 
res . status (400) . send (e: 
else if (! user) 
II Username not in the 
database 
r es . status (4 01 ) . json ({ 
error : "Bad usernarne " }); 
else { 
II Does given password 
match the database password has 
if 
(bcrypt . cornpareSync (req . body . pa: 
user . passwordHash )) { 
II Send back a toke 
contains the user's username 
const token = jwt . e1 
usernarne : user . usernarne }, secri 
res . j son ( { token : t< 
} ) ; 
else 
res . status (401) . jso1 
error : "Bad password" }); 
} ) ; 
} 
} ) ; 
II Gets the status of all users 
given a valid token 
router . get ("/status" , function (: 
res) { 
I I Check if the X-Auth heade. 
set 
if (! req . headers [ "x-auth" ]) 
return 
res . status (401) . json ({ error : "M· 
X-Auth header" }); 
} 
II X-Auth should contain the 
const token = req . headers [ "x· 
auth" ]; 
try { 
const decoded = 
jwt . decode (token , secret); 
II Send back all username 
status fields 
User . find ({}, " usernarne s 
function (err, users) { 
res . json (users); 
~---''· 
36/37 
11/17/24, 12:11 PM 
I 
zyBooks 
I 
I 
J , 
catch (ex ) 
res .status (401) . json ({ er: 
"Invalid JWT" } ) ; I PARTICIPATION 9.3.5: Securing users' passwords. ACTIVITY 
I module . exports = router; 
Which of these techni ues should develo ers use to im rove securit of an authentication 
system? 
7) Use HTTPS for login webpages. 
0 Use 
0 Don't use 
2) Display an "account not found" 
message when a user attempts to 
authenticate with an email address 
that is not in the database. 
0 Use 
0 Don't use 
3) Provide a password recovery 
mechanism. 
0 Use 
0 Don't use 
4) Force users to answer security 
questions when creating an account 
that can be asked when the user wants 
to reset a password. 
0 Use 
0 Don't use 
5) Financial websites should only log 
users out when they click the Logout 
link. 
0 Use 
0 Don't use 
6) Temporarily disable an account after a 
preset number of unsuccessful login 
attempts. 
https://leam.zybooks.com/zybook/ARIZONAECE413SalehiF all2024/chapter/9/print 
D 
0 
0 
0 
0 
0 
0 
37/37 